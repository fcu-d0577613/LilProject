<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./style/login.css">
</head>

<body>
    <div class="container">
        <div class="wrapper">

            <div class="left">
                <!-- <img src="./img/aerobic1.jpg" alt=""> -->
            </div>

            <div class="right">
                <div class="logbox">
                    <img src="./img/logo.png" alt="">
                    <h1>登入</h1>
                    <input type="text" placeholder="電子信箱"><br>
                    <input type="text" placeholder="密碼">
                    <p class="forget">忘記密碼?</p>
                    <button class="login">登入</button>
                    <p class="oror">或</p>
                    <button class="login_goole">透過GOOGLE 帳戶繼續操作</button>
                    <p>繼續使用代表你同意 Pinterest 的 <span>《服務條款》</span>，並確認你已詳閱我們的 <span>《隱私權政策》</span></p>
                    <p>您是新用戶嗎? <span>建立帳戶</span></p>
                </div>
            </div>

        </div>
    </div>




    <script src="js/three.js/build/three.js"></script>
    <script src="js/three.js/build/three.min.js"></script>
    <!-- <script src="js/three.js/examples/js/libs/stats.min.js"></script> -->
    <script type="module" src="js/three.js/src/helpers/AxesHelper.js"></script>
    <!-- <script type="text/javascript" src="./node_modules/dat.gui/build/dat.gui.js"></script> -->
    <script src="js/three.js/examples/js/loaders/GLTFLoader.js"></script>
    <script src="js/three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="js/three.js/examples/js/libs/stats.min.js"></script>
    <script src="../js/three.js/examples/js/loaders/RGBELoader.js"></script>


    <script type="module">
        
        const scene = new THREE.Scene();

        const gridHelper = new THREE.GridHelper(10, 10, 0xaec6cf, 0xaec6cf);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // const geometry = new THREE.BoxGeometry();
        // const material = new THREE.MeshBasicMaterial({
        //   color: 0x00ff00,
        //   wireframe: true,
        // });

        // const earth = new THREE.Mesh(geometry, material);
        // cube.position.set(0, 0.5, -10);
        // scene.add(cube);
        const loader = new THREE.TextureLoader();
        loader.load('./img/BG.png', function (texture) {
            scene.background = texture;
        });

        

    

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }
// add a moon light
const moonLight = new THREE.DirectionalLight(
  new THREE.Color("#77ccff").convertSRGBToLinear(),
  0,
);
moonLight.position.set(-10, 20, 10);
moonLight.castShadow = true;
moonLight.shadow.mapSize.width = 512;
moonLight.shadow.mapSize.height = 512;
moonLight.shadow.camera.near = 0.5;
moonLight.shadow.camera.far = 100;
moonLight.shadow.camera.left = -10;
moonLight.shadow.camera.bottom = -10;
moonLight.shadow.camera.top = 10;
moonLight.shadow.camera.right = 10;
scene.add(moonLight);

// controler
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.dampingFactor = 0.05;
controls.enableDamping = true;


(async function () {
    // HDR
    let pmrem = new THREE.PMREMGenerator(renderer);
    let envmapTexture = await new THREE.RGBELoader().loadAsync("./img/half earth.hdr");  
    let envMap = pmrem.fromEquirectangular(envmapTexture).texture;



    let textures = {
        bump: await new THREE.TextureLoader().loadAsync("./img/earthbump.jpg"),
        map: await new THREE.TextureLoader().loadAsync("./img/earthmap.jpg"),
        spec: await new THREE.TextureLoader().loadAsync("./img/earthspec.jpg"),
        planeTrailMask: await new THREE.TextureLoader().loadAsync("./img/mask.png"),
    };
    // const geometry = new THREE.SphereGeometry(1, 32, 32);
    //     const textureLoader = new THREE.TextureLoader();
    //     const texture = textureLoader.load('./img/original.jpg');
    //     const material = new THREE.MeshBasicMaterial({ map: texture });
    //     const cube = new THREE.Mesh(geometry, material);
    //     scene.add(cube);
  // make a earth
    const earth = new THREE.Mesh(
        new THREE.SphereGeometry(1.2 , 32, 32),
        new THREE.MeshPhysicalMaterial({
            map: textures.map,
            roughnessMap: textures.spec,
            bumpMap: textures.bump,
            bumpScale: 0.65,
            envMap,
            envMapIntensity: 0.5,
            sheen: 1,
            sheenRoughness: 1,
            sheenColor: new THREE.Color("#4a1b87").convertSRGBToLinear(),
            clearcoat: 0.5,

        })
    );
    earth.rotation.y += Math.PI * 1.25;
    earth.receiveShadow = true;
    scene.add(earth);

    // add plane
    let plane = (await new THREE.GLTFLoader().loadAsync("./img/plane/scene.glb")).scene.children[0];
    let planesData = [
        makePlane(plane, textures.planeTrailMask, envMap, scene),
        makePlane(plane, textures.planeTrailMask, envMap, scene),
        makePlane(plane, textures.planeTrailMask, envMap, scene),
        makePlane(plane, textures.planeTrailMask, envMap, scene),
        makePlane(plane, textures.planeTrailMask, envMap, scene),
        makePlane(plane, textures.planeTrailMask, envMap, scene),
    ];



    let clock = new THREE.Clock();
    renderer.setAnimationLoop(()=>{
        let delta = clock.getDelta();
        earth.rotation.y += delta * 0.05;

        

        planesData.forEach(planeData => {
            let plane = planeData.group;
          
            plane.position.set(0,0,0);
            plane.rotation.set(0,0,0);
            plane.updateMatrixWorld();
         
            planeData.rot += delta * 0.25;
            plane.rotateOnAxis(planeData.randomAxis, planeData.randomAxisRot); // random axis
            plane.rotateOnAxis(new THREE.Vector3(0, 1, 0), planeData.rot);    // y-axis rotation
            plane.rotateOnAxis(new THREE.Vector3(0, 0, 1), planeData.rad);    // this decides the radius
            plane.translateY(planeData.yOff);
            plane.rotateOnAxis(new THREE.Vector3(1,0,0), +Math.PI * 0.5);
          });



        controls.update();
        renderer.render(scene, camera);
    });

    
    function lerp(x, y, a) {
            return (1 - a) * x + a * y;
        }

        // Used to fit the lerps to start and end at specific scrolling percentages
        function scalePercent(start, end) {
            return (scrollPercent - start) / (end - start);
        }

        const animationScripts = [];

        //add an animation that flashes the cube through 100 percent of scroll
        // flashlight
        // animationScripts.push({
        //   start: 0,
        //   end: 101,
        //   func: () => {
        //     let g = material.color.g;
        //     g -= 0.05;
        //     if (g <= 0) {
        //       g = 1.0;
        //     }
        //     material.color.g = g;
        //   },
        // });

        //add an animation that moves the cube through first 40 percent of scroll
        animationScripts.push({
            start: 0,
            end: 40,
            func: () => {
                camera.lookAt(earth.position);
                camera.position.set(0, 1.5, 3);
                earth.position.z = lerp(-10, 0, scalePercent(0, 40));
                plane.position.z = lerp(-10, 0, scalePercent(0, 40));
       
                // scene.children[1].position = [-10, 0, 0];
                //console.log(earth.position.z)
            },
        });

        //add an animation that rotates the earth between 40-60 percent of scroll
        animationScripts.push({
            start: 40,
            end: 60,
            func: () => {
                camera.lookAt(earth.position);
                camera.position.set(0, 1, 2);
                // earth.rotation.z = lerp(0, Math.PI, scalePercent(40, 60));
                //console.log(earth.rotation.z)
            },
        });

        //add an animation that moves the camera between 60-80 percent of scroll
        animationScripts.push({
            start: 60,
            end: 80,
            func: () => {
                camera.position.x = lerp(0, 5, scalePercent(60, 80));
                camera.position.y = lerp(1, 5, scalePercent(60, 80));
                camera.lookAt(earth.position);
                //console.log(camera.position.x + " " + camera.position.y)
            },
        });

        //add an animation that auto rotates the earth from 80 percent of scroll
        animationScripts.push({
            start: 80,
            end: 101,
            func: () => {
                //auto rotate
                earth.rotation.x += 0.01;
                earth.rotation.y += 0.01;
            },
        });

        function playScrollAnimations() {
            animationScripts.forEach((a) => {
                if (scrollPercent >= a.start && scrollPercent < a.end) {
                    a.func();
                }
            });
        }

        let scrollPercent = 0;

        document.body.onscroll = () => {
            //calculate the current scroll progress as a percentage
            scrollPercent =
                ((document.documentElement.scrollTop || document.body.scrollTop) /
                    ((document.documentElement.scrollHeight ||
                        document.body.scrollHeight) -
                        document.documentElement.clientHeight)) *
                100;
            document.getElementById('scrollProgress').innerText =
                'Scroll Progress : ' + scrollPercent.toFixed(2);
        };

        function animate() {
            requestAnimationFrame(animate);

            playScrollAnimations();
            render();
            // if ( mixer ) mixer.update( clock.getDelta() );
            earth.rotation.x += 0.001;
            earth.rotation.y += 0.001;
        

            // stats.update();
        }

        function render() {
            renderer.render(scene, camera);
        }

        window.scrollTo({ top: 0, behavior: 'smooth' });
        animate();
})();



// make plans
function makePlane(planeMesh, trailTexture, envMap, scene) {
    let plane = planeMesh.clone();
    plane.scale.set(0.0001, 0.0001, 0.0001);
    plane.position.set(1,0,0);
    plane.rotation.set(1,0,0);
    plane.updateMatrixWorld();
  
    plane.traverse((object) => {
      if(object instanceof THREE.Mesh) {
        object.material.envMap = envMap;
        object.sunEnvIntensity = 1;
        object.moonEnvIntensity = 0.3;
        object.castShadow = true;
        object.receiveShadow = true;
      }
    });
    
    let trail = new THREE.Mesh(
        new THREE.PlaneGeometry(0.01, 0.02),
        new THREE.MeshPhysicalMaterial({
          envMap,
          envMapIntensity: 3,

          roughness: 0.4,
          metalness: 0,
          transmission: 1,
    
          transparent: true,
          opacity: 1,
          alphaMap: trailTexture,
        })
      );
      trail.sunEnvIntensity = 1;
      trail.moonEnvIntensity = 0.7;
      trail.rotateX(Math.PI);
      trail.translateY(1.1);
    
      let group = new THREE.Group();
      group.add(plane);
      group.add(trail);
    
      scene.add(group);
  
    return {
        group,
        yOff: 0.005 + Math.random() * 1.0,
        rot: Math.PI * 2,  // just to set a random starting point
        rad: Math.random() * Math.PI * 0.45 + Math.PI * 0.05,
        randomAxis: new THREE.Vector3(nr(), nr(), nr()).normalize(),
        randomAxisRot: Math.random() * Math.PI * 2,
    };
  }

  function nr() {
    return Math.random() * 2 - 1;
  }








    </script>
</body>

</html>